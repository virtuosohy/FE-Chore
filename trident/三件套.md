# html标签

## 1.`<abbr>`标签

`<abbr>`标签用于缩写字母缩略词

```html
<abbr title="Hypertext Markup Language">HTML</abbr>  //
```

我们使用`<abbr>`标签的`title`属性来显示缩写/首字母缩略词的描述，当你悬停在元素上时会显示:





## 2. `<s>`标签

- `<s>`用于删除线。
- 用于更正而不破坏更改历史。



```html
Buy for <s>$200</s> $100

```



> `<del>`和`<ins>`对类似，但在语义上用于文档更新而不是更正。

```html
My favorite programming language is <del>JavaScript</del> <ins>TypeScript</ins>

```





## 3. `<mark>`标签

- 标记或高亮文本。


- 默认为黄色背景:

```html
Coding <mark>Beauty</mark> Website
```





## 4. `<wbr>`标签

- `<wbr>`告诉浏览器，"你只能在这里和那里断开文本"
- `wbr` -- Word BReak Opportunity



```html
<p>this-is-a-very-long-te<wbr />xt-created-to-test-the-wbr-tag</p>
```

> 会在te那里断开换行





## 5.`<details>`标签

`<summary> `是用来展示标题的

`<details>`全是关于展开和收缩的

```html
<details>
  <summary>Lorem Ipsum</summary>
  Lorem ipsum dolor sit, amet consectetur adipisicing elit. Deleniti eos quod fugiat quasi repudiandae, minus quae facere. Sed, quia? Quod cupiditate asperiores neque iste consectetur tempore eum repellat incidunt qui.
</details>

```





## 6. `<optgroup>`标签

可以将巨大的选项列表分组为清晰的层次结构

```html
<select name="country" id="countries">
  <optgroup label="North America">
    <option value="us">United States</option>
    <option value="ca">Canada</option>
  </optgroup>
  <optgroup label="Europe">
    <option value="uk">United Kingdom</option>
    <option value="fr">France</option>
  </optgroup>
</select>

```

国家 → 大洲。



## 8. `<datalist>`标签

让文本输入更加轻松

```html
<form>
  <label for="lang">Choose a language:</label>
  <input list="langs" name="lang" id="lang" />
  <!--  <input> 连接到 <datalist> -->
  <datalist id="langs">
    <option value="English" />
    <option value="French" />
    <option value="Spanish" />
    <option value="Chinese" />
    <option value="German" />
  </datalist>
</form>

```





## 9. `<fieldset>`标签



`<fieldset>`创建一组字段

`<legend>`标签为`<fieldset>`元素定义标题



```html
<form>
  <fieldset>
    <legend>名字</legend>
    
    <label for="fname">名字:</label>
    <input type="text" id="fname" name="fname" /><br />
    
    <label for="mname">中间名:</label>
    <input type="text" id="mname" name="mname" /><br />
    
    <label for="lname">姓:</label>
    <input type="text" id="lname" name="lname" />
  </fieldset>
  
  <br />
  <label for="email">电子邮箱:</label>
  <input type="email" id="email" name="email" /><br /><br />
  
  <label for="password">密码:</label>
  <input type="password" id="password" name="password" />
</form>

```









# es新特性

## 1.let和const关键字

- let关键字用于声明一个块级作用域的变量。与以前的var关键字不同，let声明的变量只在其所在的块级作用域内有效，而不会被**提升**到函数作用域。这意味着在使用let声明的变量之前，必须先进行声明，否则会抛出ReferenceError错误。


- const关键字用于声明一个常量，其值在声明后不能再改变。const声明的变量也是块级作用域的，与let类似，但其值是不可变的。



```javascript
if (true) {
  let x = 10; // 块级作用域变量
  const y = 20; // 块级作用域常量
  console.log(x); // 输出: 10
  console.log(y); // 输出: 20
  y = 10;//报错: Assignment to constant variable.
}

console.log(x); // 报错: x is not defined
console.log(y); // 报错: y is not defined


```





## 2.函数参数默认值

- 我们可以在函数参数中设置默认值。这意味着如果调用函数时没有为参数提供值，它们将使用默认值。这对于简化函数调用和处理缺少参数的情况非常有用。

```javascript
function greet(name = "World") {
  console.log(`Hello, ${name}!`);
}

greet(); // 输出：Hello, World!
greet("hhh"); // 输出：Hello, hhh!

	
```





## 3.模板字符串

- ​

- 模板字符串是ES6中引入的一种新的字符串语法。它允许在字符串中插入变量或表达式，而不需要使用字符串拼接符号。模板字符串使用反引号``包围，并使用`${}`语法来插入变量或表达式。

  在`${}`语法中，我们可以放置任何有效的JavaScript表达式，这些表达式的值将被插入到字符串中

  ​

- 模板字符串是ES6中引入的一种新的字符串语法。它允许在字符串中插入变量或表达式，而不需要使用字符串拼接符号。模板字符串使用反引号``包围，并使用`${}`语法来插入变量或表达式。

  在`${}`语法中，我们可以放置任何有效的JavaScript表达式，这些表达式的值将被插入到字符串中。

  ​

- 模板字符串是ES6中引入的一种新的字符串语法。它允许在字符串中插入变量或表达式，而不需要使用字符串拼接符号。模板字符串使用反引号``包围，并使用`${}`语法来插入变量或表达式。

  在`${}`语法中，我们可以放置任何有效的JavaScript表达式，这些表达式的值将被插入到字符串中。

  ​

模板字符串是ES6中引入的一种新的字符串语法。它允许在字符串中插入变量或表达式，而不需要使用字符串拼接符号。模板字符串使用'' 包围，并使用${}`语法来插入变量或表达式。

在`${}`语法中，我们可以放置任何有效的JavaScript表达式，这些表达式的值将被插入到字符串中



```js
const name = "world";
console.log(`hello ${name}`); // 输出: hello world

//插入dom标签
const parent = document.querySelector('.parent');
const content = '这是一个div标签'
const templateString = `<div>${content}</div>`;
parent.innerHTML = templateString;

```



## 4.扩展操作符

- 扩展操作符用于展开可迭代对象（如数组、字符串等），将其元素逐个展开，以便于在函数调用、数组字面量、对象字面量等地方使用。
- 在使用扩展操作符时，你需要在要展开的可迭代对象前面加上三个点（...）。
- ​

> 1.展开数组

```js
const arr1 = [1, 2, 3];
const arr2 = [...arr1, 4, 5]; // [1, 2, 3, 4, 5]

```



> 2.传递参数给数组

```js
function sum(a, b, c) {
  return a + b + c;
}

const numbers = [1, 2, 3];

const result = sum(...numbers); // 6

```



> 3.浅拷贝数组和对象

```js
const arr1 = [1, 2, 3];
const arr2 = [...arr1]; // [1, 2, 3]

const obj1 = {name: 'Alice', age: 20};
const obj2 = {...obj1}; // {name: 'Alice', age: 20}

```





## 5.解构赋值

ES6的解构赋值语法允许我们从数组或对象中提取值，并将它们赋给变量。





1.提取数组元素

假设你有一个数组，你想要将其中的元素赋值给不同的变量：

```javascript
const numbers = [1, 2, 3, 4, 5];
const [first, second, third, fourth, fifth] = numbers;
console.log(first); // 输出: 1
console.log(second); // 输出: 2
```

2. 交换变量的值

在不使用临时变量的情况下交换两个变量的值：

```javascript
let a = 1;
let b = 2;
[a, b] = [b, a];
console.log(a); // 输出: 2
console.log(b); // 输出: 1
```

3. 从函数返回多个值

当你的函数需要返回多个值时，你可以使用解构赋值来接收这些值：

```javascript
function getMinMax(numbers) {
  const min = Math.min(...numbers);
  const max = Math.max(...numbers);
  return [min, max];
}

const [min, max] = getMinMax([10, 20, 30, 40, 50]);
console.log(min); // 输出: 10
console.log(max); // 输出: 50
```

4. 忽略某些元素

如果你只对数组中的某些元素感兴趣，你可以忽略其他的元素：

```javascript
const [, , thirdElement] = [1, 2, 3, 4, 5];
console.log(thirdElement); // 输出: 3
```

5. 使用剩余参数提取剩余元素

当你不确定数组的长度，但想要提取除前几个元素之外的所有元素时，可以使用剩余参数（rest parameter）：

```javascript
const [first, second, ...rest] = [1, 2, 3, 4, 5];
console.log(first); // 输出: 1
console.log(second); // 输出: 2
console.log(rest); // 输出: [3, 4, 5]
```

6. 与对象解构结合

如果数组中包含对象，你可以同时解构数组和对象：

```javascript
const users = [
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 30 }
];

const [ { name: userName }, { age: userAge } ] = users;
console.log(userName); // 输出: Alice
console.log(userAge); // 输出: 30
```

7. 函数参数解构

在函数参数中使用解构，使得代码更加简洁：

```javascript
function printCoords([x, y]) {
  console.log(`X: ${x}, Y: ${y}`);
}

printCoords([3, 4]); // 输出: X: 3, Y: 4
```

通过这些例子，你可以看到解构赋值如何使数组操作更加直观和简洁。它不仅可以减少代码量，还可以提高代码的可读性。

## 6.promise

- Promise是一个表示**异步操作**最终完成或失败的对象。
- 它可以有三种状态：
    - `pending`（进行中）
    - `resolved`（已完成）
    - `rejected`（已失败）



```js
const myPromise = new Promise((resolve, reject) => {
  // 通过setTimeout模拟了一个耗时1秒的异步操作
  setTimeout(() => {
    const randomNumber = Math.random();
    if (randomNumber > 0.5) {
      // 操作成功，调用resolve函数
      resolve(randomNumber);
    } else {
      // 操作失败，调用reject函数
      reject(new Error('操作失败'));
    }
  }, 1000);
});

// 使用then方法处理Promise的结果
myPromise.then((result) => {
  console.log('操作成功:', result);
}).catch((error) => {
  console.log('操作失败:', error);
});

```



- **then()**：用于处理异步操作成功的情况

- **catch()**：用于处理异步操作失败的情况。

- **Promise.resolve()** ：将对象转为状态为`resolved`的Promise对象(等价于`new Promise(resolve => resolve())`)

  **Promise.reject()** ：将对象转为状态为`rejected`的Promise对象(等价于`new Promise((resolve, reject) => reject())`)

  ​

```js
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Promise 1");
  }, 2000);
});

const promise2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Promise 2");
  }, 1000);
});

const promise3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Promise 3");
  }, 3000);
});

Promise.all([promise1, promise2, promise3])
  .then((results) => {
    console.log(results); // ['Promise 1', 'Promise 2', 'Promise 3']
  })
  .catch((error) => {
    console.error(error);
  });

Promise.race([promise1, promise2, promise3])
  .then((results) => {
    console.log(results); // Promise 2
  })
  .catch((error) => {
    console.error(error);
  });

```





```js
// 将一个值转化为 resolved 的 Promise 对象
const promise1 = Promise.resolve(42);
// 将一个值转化为 rejected 的 Promise 对象
const promise2 = Promise.reject(42);

promise1.then((result) => {
  console.log(result); // 输出：42
});

promise2.catch((error) => {
  console.log(error); // 输出：42
});


```





## 7.map和set

### Map

- Map是一种键值对的集合(**Hash 结构**)，它类似于对象，但有一些不同之处。Map的键可以是任意类型的值，包括对象和函数，而对象只能使用字符串作为键。此外，Map的键值对是有序的，插入顺序决定了键值对的顺序

- 方法

    - **get()** ：返回键值对
    - **set()** ：添加键值对，返回实例
    - **delete()** ：删除键值对，返回布尔值
    - **has()** ：检查键值对，返回布尔值
    - **clear()** ：清除所有成员
    - **keys()** ：返回以键为遍历器的对象
    - **values()** ：返回以值为遍历器的对象
    - **entries()** ：返回以键和值为遍历器的对象
    - **forEach()** ：使用回调函数遍历每个成员

  ​

```js
// 创建一个空的Map
let map = new Map();

// 添加键值对
map.set('name', 'John');
map.set('age', 30);

// 获取值
console.log(map.get('name')); // John

// 检查是否包含某个键
console.log(map.has('age')); // true

// 删除键值对
map.delete('age');

//返回长度
console.log(map.size); // 1

```





### Set

- Set是一种不重复值的集合，类似于数组，但是它的值是唯一的，不会重复。Set可以存储任意类型的值，包括原始类型和对象。
- 方法
    - **add()** ：添加值，返回实例
    - **delete()** ：删除值，返回布尔值
    - **has()** ：检查值，返回布尔值
    - **clear()** ：清除所有成员
    - **keys()** ：返回以属性值为遍历器的对象
    - **values()** ：返回以属性值为遍历器的对象
    - **entries()** ：返回以属性值和属性值为遍历器的对象
    - **forEach()** ：使用回调函数遍历每个成员



```js
// 创建一个空的Set
let set = new Set();

// 添加值
set.add(1);
set.add(2);
set.add(2);
set.add(3);

// 检查是否包含某个值
console.log(set.has(2)); // true

// 删除值
set.delete(3);

//返回实例成员总数
console.log(set.size); // 2

```



## 8.迭代器

- `forEach` 是数组的专用方法，只能用于数组。
- `for...in` 可以用于遍历数组和对象的属性，但不能保证属性的遍历顺序。
- `forEach` 通常用于数组元素的遍历，而 `for...in` 更适用于遍历对象的属性。



### forEach

`forEach` 是数组的高阶函数，用于遍历数组中的每个元素。它接受一个回调函数作为参数，该回调函数会在数组的每个元素上执行。

```js
const numbers = [1, 2, 3, 4, 5];

numbers.forEach(function(number, index) {
  console.log(`Index: ${index}, Value: ${number}`);
});

//会输出数组的每个元素的索引和值
```



### for...in

`for...in` 循环用于遍历一个对象的所有可枚举属性。它可以用来遍历数组和对象。

```js
const obj = {
  a: 1,
  b: 2,
  c: 3
};

for (const key in obj) {
  if (obj.hasOwnProperty(key)) {
    console.log(`Key: ${key}, Value: ${obj[key]}`);
  }
}
```





### 迭代器（Iterator）

- 迭代器（Iterator）是一种迭代的机制，为各种不同的数据结构提供统一的访问机制。任何数据结构只要内部有 Iterator 接口，就可以完成依次迭代操作。
- 默认的 Iterator 接口部署在数据结构的`Symbol.iterator`属性，或者说，一个数据结构只要具有`Symbol.iterator`属性，就可以认为是“**可遍历的**”。
- 原生具备 Iterator 接口的数据结构如下：
    - Array
    - Map
    - Set
    - String
    - TypedArray
    - 函数的 arguments 对象
    - NodeList 对象
- 迭代器对象方法：
    - **next()** ：下一步操作，返回`{ value,done }`(必须部署)
    - **return()** ：`for-of`提前退出调用，返回`{ done: true }`
    - **throw()** ：不使用，配合`Generator函数`使用



```js
let arr = ['a', 'b', 'c'];
let iter = arr[Symbol.iterator]();

iter.next() // { value: 'a', done: false }
iter.next() // { value: 'b', done: false }
iter.next() // { value: 'c', done: false }
iter.next() // { value: undefined, done: true }

```



### for...of 循环

- `for...of`循环用于遍历可迭代对象（例如数组、字符串、Set、Map等），它会迭代对象中的每个元素并执行指定的代码块。



> 遍历数组：

```js
let arr = [1, 2, 3, 4];

for(let element of arr) {
  console.log(element);
}
// 输出：
// 1
// 2
// 3
// 4

```



> 遍历字符串

```js
let str = "Hello";

for(let char of str) {
  console.log(char);
}
// 输出：
// H
// e
// l
// l
// o

```



> 遍历set和map元素

```js
let set = new Set([1, 2, 3]);

for(let value of set) {
  console.log(value);
}
// 输出：
// 1
// 2
// 3

let map = new Map([
  ['name', 'John'],
  ['age', 30]
]);

for(let [key, value] of map) {
  console.log(key, value);
}
// 输出：
// name John
// age 30

```





## 9.ES8

### Object.entries()

- `Object.entries()`方法返回一个给定对象自身可**枚举属性**的键值对数组



```js
let obj = {a:1,b:2}
for (let [key, value] of Object.entries(obj)) {
    console.log(`${key}: ${value}`)
}
//输出
// a: 1
// b: 2

```



### Object.values()

- `Object.values()`方法返回一个给定对象自身可枚举属性值的数组



```js
let obj = {a:1,b:2}
console.log(Object.values(obj));//[ 1, 2 ]

```



### padStart()

- `padStart()`方法可以在字符串的开头添加指定的字符，直到字符串达到指定的长度。如果字符串的长度已经达到或超过了指定的长度，则不会进行任何填充。

```js
let phoneNumber = "18912345677"; // 电话号码

let paddedPhoneNumber = phoneNumber.slice(-4).padStart(11, "*"); 

// 将电话号码填充到11位，使用*进行填充，并且只保留后四位数

console.log(paddedPhoneNumber); // *******5677

```



### padEnd()

- `padEnd()`方法与`padStart()`方法类似，不同之处在于它在字符串的结尾添加指定的字符，直到字符串达到指定的长度。



```js
const text = 'Hello';
console.log(text.padEnd(8, '!')); // 输出：'Hello!!!'

```





## 10.ES9

### Rest/Spread 属性

`Rest/Spread` 属性语法是对扩展运算符的一种扩展。`Rest/Spread `属性允许我们在对象字面量中使用扩展运算符（`...`）来获取对象的剩余属性或将属性扩展到另一个对象中。

`Rest` 属性用于从对象中提取剩余的属性，并将它们作为新的对象返回。这样可以方便地从一个对象中提取所需的属性，而不必一个一个地进行赋值。



```js
const { name, age, ...rest } = { name: 'hhh', age: 18, sex: '男', city: '上海' };
console.log(name); // "hhh"
console.log(age); // 18
console.log(rest); // { sex: '男', city: '上海 }

```



- `Spread` 属性用于将一个对象的属性扩展到另一个对象中。这样可以方便地合并两个对象的属性，而不必一个一个地进行赋值。

```js
const obj1 = { name: 'hhh', age: 18 };
const obj2 = { sex: '男', city: '上海' };
const mergedObj = { ...obj1, ...obj2 };
console.log(mergedObj); // { name: 'hhh', age: 18, sex: '男', city: '上海' }

```

















































